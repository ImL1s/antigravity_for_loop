Ralph Wiggum 迴圈的原理與 Antigravity antigravity_for_loop 插件設計

Ralph Wiggum 自動迴圈的實作原理

Ralph Wiggum（簡稱 Ralph Loop）是 Claude Code 環境中的一款官方插件，用來讓 AI 編程助手進行持續的自動迴圈開發。它得名於《辛普森家庭》中屢敗屢戰的角色 Ralph Wiggum，寓意 AI 會“不斷失敗卻持續嘗試”，直到完成任務 ￼ ￼。這個插件的核心目標，是在沒有人工介入的情況下讓 Claude Code 反覆執行同一任務，持續修改程式碼直到滿足「完成」標準 ￼。

迴圈控制邏輯：Stop Hook 與提示重注入

Ralph Loop 能實現自動迴圈，主要是利用 Claude Code 的 Hook 機制，攔截 AI 原本的結束動作，從而強制進入下一次迭代 ￼。具體來說，Claude Code 支援在特定事件時自動執行外部腳本的 Hook，其中 Stop Hook 在 AI嘗試結束任務時觸發。Ralph 插件在 Stop Hook 上做了關鍵處理：當 Claude 想退出時，Stop Hook 攔截退出，阻止 Claude 結束，並將原始的提示（prompt）重新塞回去 ￼。換言之，每當 AI覺得任務完成準備停止時，插件都讓它重新讀取一開始的任務要求並繼續下一輪迭代。

為了實現上述行為，Ralph 插件在背後維護了一個狀態檔來追蹤迴圈進度（例如當前迭代次數、最大迭代上限、完成關鍵字等） ￼。當使用者執行 /ralph-loop "<任務>" --max-iterations N --completion-promise "<文字>" 命令時，插件會建立該狀態檔 .claude/ralph-loop.local.md，寫入初始提示內容和參數設定 ￼。同時，插件會啟用 Stop Hook 監聽Claude的退出事件 ￼。Claude 隨即開始第一次迭代：讀取使用者提供的任務提示，嘗試產生程式碼或進行修改。迴圈流程如下所示：
	1.	執行任務： Claude Code 主代理（AI助手）依據提示開始編寫/修改程式碼或執行指令。 ￼
	2.	嘗試退出： Claude 認為任務可能完成，準備產生最終答案/結論並結束此次回合。 ￼
	3.	Stop Hook 攔截： 插件的 Stop Hook 在 Claude 試圖結束時被觸發 ￼。Hook 腳本檢查狀態檔，發現當前 Ralph 迴圈尚未達到終止條件，於是返回特殊狀態碼和訊息阻止 AI 停止 ￼ ￼。Claude Code 平台會識別這個阻斷信號（"decision": "block" 的 JSON 返回值），因此不結束對話 ￼。
	4.	重置提示並繼續： Stop Hook 所執行的腳本將原始任務提示重新提供給 Claude，讓 AI 在同一對話中看到自己先前的輸出、修改過的檔案和Git歷史，並把任務當作尚未完成重新開始下一次迭代 ￼。從Claude的角度，相當於使用者再次提出相同要求，但此時環境中文件內容已更新、之前的執行結果也在對話上下文中，AI 會基於先前的失敗經驗進一步改進。 ￼ ￼
	5.	持續迭代： 步驟1~4會持續重覆，直到滿足停止條件為止（例如成功完成任務或達到迭代上限） ￼。

在整個過程中，Stop Hook 是實現自動重試的關鍵：透過讓 Hook 腳本對 Claude Code 返回 exit code 2 並輸出 decision: "block" 的 JSON，Claude Code 平台會中斷原本的退出流程，並將 Hook 提供的訊息當作新一輪對話輸入，迫使 AI 進入下一迴圈 ￼。這種巧妙的 “攔截+重放” 機制，實現了類似 while(true) 的無限迴圈效果，但又可由插件程式受控終止。

**說明：**Geoffrey Huntley（Ralph 技術的創始人）將其原理歸結為一句話：“Ralph is a Bash loop.” ￼ ￼也就是像 while :; do ... done 這樣不斷執行同一提示的死循環。在官方插件中，這個 Bash 循環透過 Stop Hook 機制包裝實現，讓 Claude Code 失敗就重試，直到成功 ￼ ￼。

Subagent 與技能的使用情況

Ralph Wiggum 插件本身並沒有啟動額外的 subagent。它並非透過多代理協作來實現迴圈，而是讓 Claude Code 的主代理在每次迭代中同時扮演「編碼者」和「測試者」的角色。Claude Code 主代理本身就能使用多種內建工具（例如 Write 編輯檔案、Bash 執行測試命令等） ￼ ￼來完成從編碼到測試的步驟。因此，Ralph 迴圈通常是由主代理直接調用這些工具實現自行檢驗和修復。例如，主代理在產生程式碼後可以自動呼叫 Bash("npm test") 來執行測試，用對話形式將測試結果（通過/失敗）顯示出來 ￼。如果測試未通過，AI 會根據失敗訊息繼續修改程式碼。整個過程是在同一代理內反覆進行，沒有額外啟動 researcher/coder/tester 等專門 subagent 的必要。

不過，Claude Code 平臺本身提供「Task Tool」來管理各類 subagent ￼。開發者也可以在 prompt 中顯式使用 Task(...) 調用特定子代理（如 tester）來跑測試。但 Ralph 插件默認不需要這樣做——它相信主代理能透過內建工具完成大部分檢測工作。如果使用者的提示已經指示 AI 執行測試，那主代理自會負責；除非 AI 沒有遵循測試指令，否則無須額外的子代理介入。

技能（Skills）方面，Ralph 插件本身沒有捆綁特定的 Claude 技能或指令集。它的迭代行為主要透過程式邏輯（Hook 控制流）達成，而不是透過提供額外的知識或規則。換言之，Ralph 迴圈的品質很大程度取決於使用者撰寫的 Prompt，而非預先內建的技能 ￼ ￼。Anthropic 官方也建議使用者在提示中明確定義完成標準及自我校驗步驟，讓 AI 知道要“邊寫邊測試，直到所有測試通過再輸出完成標記” ￼ ￼。舉例而言，一個好的 Prompt 會寫明：「完成的標誌是所有單元測試通過並輸出 <promise>DONE</promise>」等等。這樣 Claude 才會在迭代中自發地運行測試、修復錯誤。

當然，用戶也可以搭配其它插件或技能提升 Ralph 迴圈效果。例如，可以啟用“後端開發指南”等 Skills，自動為 Claude 加載相關的編碼規範；或者使用“安全提醒”插件在 Claude 執行危險命令時給出警告 ￼。但這些都不是 Ralph 插件自身的一部分，而是額外的輔助。總之，Ralph 的迴圈重試不靠隱藏的知識或提示，完全是透過 Stop Hook 強制 AI 多次「閱讀自己的代碼變更和執行結果」，從而逐步改進 ￼。

權限處理與安全控制

權限方面，Ralph 插件運行在 Claude Code 環境中，需要適當的權限設定來順利執行迴圈內的各種動作。Claude Code 本身對 AI 執行終端命令有一套政策控制，例如 Off / Auto / Turbo 三種模式 ￼。在 Ralph 迴圈中，建議將終端執行權限設為 Auto（代理自動決定），以便讓 AI 無需每次都等待人工許可就能執行安全的命令（如跑測試、編譯程式等）。Auto 模式下，Claude 會在大多數情況下自動執行命令，只有當命令可能有風險時才請求用戶確認 ￼。這種設定確保常規的測試/建構命令可以反覆自動執行，不會卡在人工確認；同時又能對潛在危險操作保持警惕。

值得注意的是，Ralph 插件本身並不繞過 Claude Code 的內建安全閘。它不會給 AI 任何額外的權限提升。換言之，如果 AI 嘗試執行被禁止的命令（例如刪除關鍵檔案、訪問外網等），Claude Code 的默認機制仍會攔截並詢問用戶允許與否。Ralph 迴圈並沒有也不應該取消這些保護。在實踐中，開發者可以預先將常用的安全命令加入允許清單，或使用官方的安全插件（如 security-guidance）即時掃描 AI 提交的程式碼與命令 ￼。例如，有安全插件會在 AI 嘗試執行 rm -rf 等高風險操作時發出警告甚至自動拒絕，防止迴圈無意中破壞專案環境。

總而言之，Ralph 依賴使用者對插件的信任與正確的權限配置。使用者在安裝 Ralph 插件時需要信任該插件（Claude Code 通常要求對插件目錄進行信任認可），因為它會讀寫專案檔案並執行shell腳本。啟動迴圈前，也要確保 AI 可以執行必要的測試/構建指令且環境已備妥（例如已經安裝依賴、設定好自動化測試）。只有在這些條件滿足下，Ralph 的自動迴圈才能不間斷地運行下去。反之，如果沒有適當權限，AI 每次執行命令都彈出確認，迴圈效率和可靠性就大打折扣。

停止條件與錯誤處理機制

Ralph 迴圈必須設定明確的停止條件，以防止 AI 無限循環或資源耗盡。官方插件提供了兩種主要停止機制：
	•	最大迭代次數 (--max-iterations)： 使用者啟動 Ralph 時可以指定一個最大迴圈次數。例如 --max-iterations 50 表示最多嘗試 50 次迭代 ￼。這是一個安全網：無論任務是否完成，只要達到上限，Stop Hook 就不再阻止 Claude 結束，讓迴圈停下來 ￼。Anthropic 官方強調每次使用 Ralph 一定要設置最大迭代數，以避免無限循環燒光 API 點數或時間 ￼。
	•	完成承諾 (--completion-promise)： 使用者可以提供一段文字作為完成任務的標誌（例如 "DONE" 或 "All tests migrated"）。Claude 每次輸出時，插件會檢查輸出內容中是否包含這個標誌字串。如果匹配到，表示 AI 宣告任務已完成，此時 Stop Hook 將允許 Claude 正常退出迴圈 ￼。不過，字串匹配畢竟是靜態且單一的判斷，可靠性有限：LLM 有時可能錯把沒完成的工作當作完成而輸出該字串，或者反過來任務早完成但沒精確輸出關鍵字 ￼。因此官方提醒 --completion-promise 只是輔助手段，不應完全依賴 ￼。實務上，完成條件最好用自動化測試/編譯來驗證，而不要只靠 AI 自己聲稱 ￼。

Ralph 插件在每次 Stop Hook 觸發時，會檢查上述條件以決定是否結束迴圈。從前文 Hook 腳本的簡化程式碼可以看出：

# （Stop Hook 腳本邏輯示意）
if [[ ! -f ".claude/ralph-loop.local.md" ]]; then
  # 沒有啟動 Ralph 迴圈，正常退出
  exit 0
fi

# 讀取當前迴圈次數和停止條件
ITERATION=$(grep '^iteration:' .claude/ralph-loop.local.md | cut -d':' -f2)
MAX_ITERATIONS=$(grep '^max_iterations:' .claude/ralph-loop.local.md | cut -d':' -f2)
COMPLETION_PROMISE=$(grep '^completion_promise:' .claude/ralph-loop.local.md | cut -d':' -f2)

# 判斷是否達到停止條件
if (( ITERATION >= MAX_ITERATIONS )); then
   # 超過最大迭代次數，清理狀態檔並允許退出
   rm ".claude/ralph-loop.local.md"
   exit 0
fi
# （此處略去檢查 completion_promise 標記是否出現的代碼，如果出現同樣 rm 檔案並 exit 0）

上面邏輯確保了迴圈不會無限制地執行下去。如果達到迭代上限或偵測到完成標記，Stop Hook 就不再阻擋 Claude，而是刪除狀態檔並讓 AI 正常終了 ￼ ￼。相反地，如果尚未達到停止條件，腳本稍後會執行阻擋並重注入提示的動作 (exit 2) ￼。

錯誤處理與卡頓迴圈檢測方面，Ralph 官方插件的邏輯相對簡單直接：它不會判斷 AI 每次迭代產出的結果品質，只要沒有達標就繼續讓 AI 重試。「失敗就是迭代的燃料」，Ralph 假定每次錯誤都能讓 AI 在下次更聰明地修正 ￼ ￼。不過在現實中，可能出現 AI 陷入重複性的錯誤（例如反覆修復同一bug但每次都失敗），造成無效循環。為應對這種情況，社群版的增強實現加入了一些**「迴圈停滯」偵測和斷路**機制：
	•	錯誤模式識別與去重： 加強版的 Ralph Loop 會分析 Claude 每次回覆或程式執行日誌中的錯誤訊息，判斷是否出現相同的錯誤重複出現。如果發現迭代間錯誤訊息一模一樣，說明 AI 可能陷入卡住狀態，持續做無效嘗試 ￼。例如某測試一再失敗且輸出相同 Stack Trace，則表明 AI 沒有找到新的解法。遇到這種情況，增強的迴圈會啟動錯誤去重策略：可以選擇跳出循環請求人工協助，或嘗試採取不同策略（例如讓 AI 重新審視方案）。這避免無謂地燒費用。
	•	語義分析與兩階段過濾： 一些實作（如 frankbria 的 ralph-claude-code）內建了回應分析器，利用 AI 模型語義理解來判斷 Claude 的回答中是否隱含錯誤或未完成的跡象，並結合正則匹配進行雙重驗證 ￼。這種兩階段錯誤檢測可過濾掉誤報（例如 Claude 回覆 JSON "is_error": false 不應算錯誤） ￼。只有確定真的卡殼，才會觸發斷路器。
	•	斷路器（Circuit Breaker）： 一旦檢測到迴圈可能「卡死」，增強版 Ralph 會暫停自動迴圈，進入半開狀態做一些恢復嘗試 ￼。比如它可能降低迭代頻率，或者提示 AI 切換思路。如果經過數次嘗試仍不見效，系統會停下來並通知用戶介入。這相當於在自動和人工之間加了一層保護，防止無止境的失敗循環 ￼ ￼。
	•	使用者提示介入： 如果自動修復迴圈實在無法取得進展，Ralph 插件提供了手動取消命令。在 Claude Code 中，可以隨時輸入 /cancel-ralph 來終止當前的 Ralph 迴圈 ￼。這對於避免無限循環非常重要——用戶可觀察 AI 輸出的中間結果，一旦覺得走偏或長時間無效，就手動停止。新的增強版本也會在觸發斷路時，主動向用戶發出提示或詢問（例如發現Claude已連續5小時運行，會提醒用戶選擇繼續等待或退出） ￼。

概括而言，Ralph 官方插件本身是「一根筋」地反覆迭代：只要沒達到完成條件就一直重試 ￼。它相信**“可預期地失敗勝過不可預期地成功”** ￼，所以與其一次性給出可能不完美的答案，不如透過機械的迴圈逼近完美解。 ￼然而考量到現實成本與風險，我們在轉換為 Antigravity 插件時，應該借鑒那些增強方案，加上錯誤檢測、迭代限流等控制，以實現更健壯安全的自動化迴圈 ￼。

Antigravity antigravity_for_loop 插件設計方案

有了 Ralph Wiggum 在 Claude Code 中的實踐經驗，我們可以設計一個適用於 Google Antigravity IDE 的類似插件，暫稱 antigravity_for_loop。這個插件的目標是讓 Antigravity 中的 AI 代理也能進行自主的反覆修復循環，實現「寫代碼 -> 執行測試/編譯 -> 根據結果自動修改，直到所有測試通過」的閉環開發流程，同時兼顧安全與可控性。以下將從架構、流程控制、權限風險以及模型/技能配置幾方面，說明如何將 Ralph 迴圈的理念融入 Antigravity 插件。

插件架構與迴圈流程設計

Antigravity 是一個強調多智能體協作的 AI 原生 IDE ￼。在設計 antigravity_for_loop 插件時，我們既可以沿用 Ralph 的 Stop Hook 機制，也可以充分利用 Antigravity Agent Manager 的能力來組織迭代流程。下面是插件整體工作的流程圖，分步說明從用戶啟動循環到自動結束的過程：
	1.	用戶啟動循環任務： 開發者在 Antigravity 中透過 /for-loop "<任務描述>" --max-iterations N [--completion "<標記>"] 命令啟動插件。插件解析命令參數，建立循環狀態（如當前迭代次數=0、最大迭代=N、完成關鍵字等），並將這些資訊存儲於一個狀態檔或內存變數中。然後，插件會在背景執行必要的初始化步驟：例如切換到臨時開發分支以承載後續改動，以及激活相關的 Hook 監聽（如 Stop Hook）以攔截 AI 的退出。 ￼ ￼
	2.	首次迭代 - 執行任務並測試： 插件將使用者提供的任務提示提交給 Antigravity 的 AI代理，使其開始嘗試完成任務。此時，Agent Manager 可能啟動默認的“Coder”子代理（或直接由主代理執行），負責根據提示編寫或修改程式碼。**關鍵的是，我們會確保在這個迭代中自動進行測試/構建：**可以通過兩種方式實現：
	•	方式A: 將測試步驟寫入提示/技能，使AI在其計劃中包含「編譯並運行測試」的子步驟。例如在提示中明確要求「寫完代碼後執行所有測試，若有失敗則修復」 ￼。Agent Manager 會據此在一次對話中自發地完成代碼編寫和測試驗證。
	•	方式B: 插件本身在編碼步驟結束後，自動觸發測試。例如可以設定一個 Post-Write Hook 或任務計畫的“驗證”階段：當 AI 完成代碼修改（或提交變更）後，由插件執行預先定義的指令（如 npm run build && npm test）。在 Antigravity 中，Agent Manager 已經體現出這種趨勢：AI 執行完代碼修改後會自動進行驗證（例如Paul測試中，AGY在更新代碼後立刻跑了 build 和 start 來驗證伺服器是否正常啟動 ￼）。我們的插件可以強化這個行為——確保每次代碼變動後，一定執行全量的測試與靜態檢查（lint），將結果收集備用。
無論採用哪種方式，第一輪迭代的結果將包括代碼改動以及測試/構建的執行結果。AI 可能在對話中輸出一些內容，例如測試通過與否的報告。如果所有測試都綠燈，AI 或許會產生「Looks good, all tests passed. DONE」這樣的完成訊息。
	3.	攔截退出並分析結果： 如果 AI 在首次迭代結束時試圖宣告任務完成或停止輸出，我們的 Stop Hook 隨即介入（這時狀態檔表明 iteration=0, max=N）。插件的 Hook 腳本會檢查任務完成條件是否滿足：
	•	若檢測到 AI 的輸出包含指定的完成標記（例如 <promise>DONE</promise>），或所有測試確實通過，則說明任務已完成。此時 Hook 不阻止退出，直接讓 AI 結束回合。插件會清理循環狀態（例如刪除狀態檔、在UI通知「迴圈完成」），整個流程在一次迭代內順利完成。
	•	如果任務尚未完成（例如還有測試失敗，或 AI 並未輸出完成標記），則插件判斷需要進入下一輪修復迴圈。接下來，Hook 腳本會執行以下操作：
	1.	收集錯誤資訊： 獲取本輪執行的測試/編譯結果。如果 AI 已在對話中提供了失敗的測試案例和錯誤訊息，我們也可以直接使用。否則，插件可以從記錄中提取，或者再次由插件代為執行測試來雙重確認結果。這一步的目的是準備好「AI 下一輪需要解決的問題清單」。例如發現有 3 個測試失敗，錯誤訊息涉及函數輸出格式不正確等。
	2.	更新狀態並準備重試： 將狀態檔中的迭代計數 +1（例如 iteration 從0變為1），同時保留完成標記和上限等原始信息。插件還可以將剛收集的錯誤摘要寫入狀態檔或暫存到某處，以便在下個回合提供給 AI 參考。
	3.	構造重新注入的提示： 和 Ralph 類似，我們將原始的任務提示重新提供給 AI，但附加上上一輪的結果/錯誤資訊，引導 AI 聚焦於修復失敗之處。具體實現上，Stop Hook 可以返回一段 JSON，包含 "decision": "block" 來攔截退出，以及新的 userMessage 字段來模擬下一輪使用者輸入 ￼。我們可以把附加資訊加進 userMessage 中。例如：

{
  "outcome": { "decision": "block" },
  "userMessage": "（迭代1）部分測試未通過：TypeError: output format is wrong at test X. 請根據以上錯誤修正代碼。原任務要求："+<原始prompt>
}

這樣，Claude在下一輪迴圈一開始，就能看到自己前一次失敗的細節以及原始任務目標，從而有針對性地進行改進。 ￼

	4.	阻止當前退出並觸發下一輪： Hook 腳本輸出上述 JSON 後，以 exit code 2 結束（表示阻斷) ￼。Antigravity 平臺會據此不中斷會話，並將我們提供的 userMessage 插入讓 AI 繼續對話，好像使用者緊接著提出了新要求一樣。從使用者角度看，AI 並未真正“停下”，而是立即開始第2輪修復迴圈。

	4.	後續迭代 - 持續修復直至完成： 第2輪及之後的流程與首輪相似：AI 閱讀了新的輸入（包含前次錯誤），然後嘗試修改程式碼修復問題 -> 執行測試/建構 -> 插件截獲退出 -> 判斷是否完成或需要再迭代。整個循環持續進行，每次都累積前序結果作為經驗。 ￼在反覆迭代中，AI 逐步解決更多的測試失敗，接近任務完成。插件則密切監控迭代次數和錯誤變化，以決定何時停手或介入。
	5.	退出迴圈： 迴圈可能以下幾種情況結束：
	•	所有測試通過 / 完成標記出現： 這是理想情況，表示AI成功完成了任務。Stop Hook 放行退出，AI 輸出最終結果（可能是一句“All tests passed. DONE”），插件在UI上提示「所有測試已通過，迴圈完成」，並可以自動執行一些收尾操作，如將修改提交 Git、通知用戶成果等。
	•	達到迭代上限： 如果已經迭代了 N 次仍未完成（比如 N=20），插件的 Stop Hook 檢測到 iteration >= max_iterations 而終止循環 ￼。AI 將在沒有完成任務的情況下停止，此時插件應向用戶報告：「已達到最大迴圈次數，但任務可能尚未完成」，並提供目前尚未解決的問題（例如仍然失敗的測試清單），建議用戶介入處理。
	•	錯誤重複卡死： 若插件的智慧監控發現 AI 連續多次迭代都在原地打轉（相同的測試失敗重複出現，程式碼反覆在幾處來回修改卻無效），則判定陷入“Stuck Loop”。為避免浪費資源，插件可以提前終止迴圈，即使尚未到最大次數。這種情況下，插件在UI上警示用戶：迴圈疑似卡住，可能需要人工協助。用戶可以選擇繼續多給幾次機會，或者直接停止讓AI輸出中間結果以便自行排查。
	•	手動取消： 插件將提供如 /cancel-loop 的命令讓用戶隨時停止正在進行的循環（相當於 Ralph 的 /cancel-ralph ￼）。一旦用戶執行取消，我們的 Hook 或協調程式會立刻清理狀態並終止後續迴圈。即使在Auto模式下，我們也尊重用戶的隨時中止權。

如上所述，Antigravity 的 antigravity_for_loop 插件將實現一個閉環的開發工作流：AI 每次修改代碼後馬上驗證，依據真實的執行結果決定後續行動（繼續修、還是完成），把人從機械的「寫碼-測試-修Bug」反覆勞動中解放出來。整個架構既結合了 Ralph 在 Claude Code 中的 Stop Hook 迴圈精髓 ￼ ，又充分運用了 Antigravity 平台的特長（多代理協作、自動化驗證）來完善流程。

權限模式與風險控制設計

在讓 AI 高度自動化地長時間運行時，權限和風險管控至關重要。我們將設計多層次的安全措施，確保 antigravity_for_loop 插件既高效自主又不失可控：
	•	終端執行政策： 建議安裝本插件的用戶將 Antigravity 的終端命令執行策略設置為 “代理決定 (Auto)” 模式 ￼。在該模式下，AI 可以自行決定執行大部分安全的命令，而對於具有不確定風險的操作則仍會徵求用戶許可 ￼。這樣一來，像 npm test、npm run lint 這些每日開發都需要的命令可在每次迭代自動執行而無須人工反覆確認；但若 AI 嘗試進行破壞性操作（例如刪除資料庫、修改關鍵系統設置等），Antigravity 仍會跳出來請用戶點頭。透過允許清單與拒絕清單配置，也能細化 Auto 模式下的行為：例如我們可以將測試/構建相關指令加入允許清單，使其在 Auto 模式下一律無需確認執行；將 rm -rf、drop database 等加入拒絕清單，哪怕 AI在Turbo模式下也直接禁止執行。總之，本插件會與Antigravity內建的終端管控配合，使常規安全操作流暢執行，高風險操作需人工確認，杜絕AI「失控」危及專案環境。
	•	檔案寫入與版本控制： 插件運行時，AI 將頻繁修改專案檔案。為降低風險，antigravity_for_loop 可以在開始循環時自動建立一個新的 Git 分支或快照，以保存原始代碼基線。所有後續 AI 修改都提交在該分支中，確保主分支或其他工作不會被搞亂。一旦循環完成，如果結果令人滿意，用戶可以將該分支合併回主線；若結果不佳，用戶可以輕鬆放棄該分支，回到原始狀態。插件也可在每次迴圈迭代後自動執行 Git 提交（commit），附上 AI 生成的描述（如 “Iteration 3: Fixed output format in function X”）。這充當patch checkpoint功能，每個patch都有歷史記錄可追溯 ￼。萬一中途AI的修改出現嚴重問題，我們可快速 reset 回先前版本。版本控制還有助於 AI 本身：Claude Code/Antigravity 的代理可以讀取 git diff 來了解自己做了哪些改變，從而在下一步更好地調整方向 ￼。
	•	輸出監控與警戒詞： 我們會實現一個輕量級的監控，檢查 AI 的對話輸出中是否出現某些警戒訊號，以便及時中止或提醒。比如：
	•	連續無效修復： 如果發現 AI 接連兩次迭代都沒有真正改動程式碼（可能只是格式改動或語意無關的修改），或同一錯誤訊息出現3次以上，則觸發“迴圈停滯”警報，插件將暫停循環並提示用戶。這與前述錯誤去重邏輯類似，是在插件層面進行保障。
	•	模型胡言亂語： 假如 AI 在某次輸出中突然偏離技術任務（例如輸出與要求無關的廢話或出現道歉語氣表示無法完成），說明代理可能陷入混亂狀態。插件可檢測特定關鍵詞（如 “I’m sorry… cannot continue” 等），一旦出現就終止循環防止浪費時間，並通知用戶 AI遇到了困難。
	•	敏感操作警告： 配合 Antigravity 的安全插件或自帶功能，例如我們可以在 Pre-ToolUse Hook 上攔截 AI 執行諸如刪檔、網絡訪問等操作。如果AI嘗試做這些高危舉動，我們可以要求它給出確認或直接deny。例如，可以利用“安全提醒 (security-guidance)”插件，在 AI 輸出或命令中發現疑似 SQL 注入、XSS 漏洞、不安全函式等模式時，立即提醒並要求 AI 調整代碼 ￼。這在高度自動化下尤為重要——因為循環過程中人不會每步審查代碼品質，故我們需要工具自動把關 代码安全与质量，避免引入重大漏洞。
	•	耗時/費用控制： 考慮到 LLM 調用成本，我們也會跟蹤迴圈已消耗的 token 和時間。如發現已執行數小時或 token 用量巨大接近配額，插件會主動暫停並詢問用戶是否繼續，防止在用戶不知情的情況下衝破使用上限 ￼。這類限流與熔斷策略可以保護用戶錢包，同時倒逼用戶檢查為何任務久拖不決。
	•	人工隨時介入： 即便我們極力讓 AI 自治，本質上人類監督仍不可或缺。插件應提供簡單明確的介面，讓使用者隨時查看迴圈狀態和中間成果。例如在 Antigravity 的Agent Manager中，可以實時看到當前 loop執行到第幾步、完成了哪些任務、還有哪些測試沒過等資訊。使用者也能點擊中間產出的檔案差異、一鍵跳轉查看AI改了哪裡。如果某步驟用戶有疑慮，可以暫停迴圈，進行人工review或調整 prompt 後再繼續。這種人機協作的審查點非常重要：尤其對於涉及架構性決策或安全敏感代碼，我們建議在插件配置中允許使用**“以審核為導向 (Request Review)”的策略 ￼，即代理每完成一個里程碑就等待用戶確認再往下（可以設為每隔幾次迴圈請人工確認一次變更）。總之，在追求自動化的同時，我們確保用戶始終有最終控制權**，可根據情況調節自主權大小。

透過以上多重措施，antigravity_for_loop 插件將在效率與安全之間取得平衡。AI 可以大膽地“通宵趕工”自動修Bug，但一旦它偏離正軌或面臨高風險操作，系統會及時拉響警報，把決策權交還人類。這種 “自主執行、監督可控” 的模式能讓開發者更加放心地利用 AI 的持續迭代能力。

模型與技能的配置建議

由於 Antigravity 支援多種 AI 模型，我們需要確保所用的模型適合長時間編程任務循環。同時，可以透過**Skill（自定義技能）**為模型提供額外的知識與指導，以提高循環成功率。

1. 模型選擇： 建議在 Antigravity 中啟用最強性能的可用模型來執行 for-loop 任務。以目前情況，Google 自家的 Gemini Pro 3.0 是不二之選，其程式編寫與推理能力極強且上下文長度充裕 ￼ ￼。若用戶擁有Anthropic Claude的API，也可以將 Claude 接入 Antigravity（例如透過 OpenAI/Anthropic 的 MCP 外掛配置密鑰），在插件中使用 Claude 2 之類的大模型。總之，模型需要在長對話、多次迭代中保持上下文並展現一致的行為。Claude 類模型在這方面表現優異（上下文長且善於遵循指令），Gemini則原生整合於Antigravity Agent Manager。如果可能，避免使用上下文較短或不善於長流程推理的模型，否則中途可能遺失關鍵信息或偏題。

2. 智能體參數調整： 可以適當降低模型的溫度（temperature），以提高每次修改的可靠性與一致性。迴圈模式更需要模型穩定地朝著解決已知錯誤的方向前進，而不是發散創新。Temperature 可考慮設置為 0.2~0.3，以減少隨機性。同時，確保 Agent Manager 的自動壓縮上下文功能不會過度丟棄重要歷史：Antigravity有自動摘要/壓縮舊上下文的機制，但對我們來說，每次迭代的錯誤細節都很重要。因此，我們建議將關鍵文件（如測試結果、關鍵代碼段）固定在上下文中，或者使用 Antigravity 的「重要資訊pin」功能（如果有）來鎖定這些內容不被裁剪。Claude Code 在200k上下文下有 auto compact 機制，Antigravity可能類似 ￼——需要確保它不妨礙我們循環的信息流。

3. 技能編寫： 為了指導模型更好地完成循環任務，我們可以在插件中提供一個專門的技能 (Skill) 文件，充當 AI 的“迭代開發指南”。這份技能將在每次 for-loop 啟動時自動加載到 AI 的上下文中，為模型提供通用的最佳實踐和項目相關知識。例如，我們可以創建 skills/antigravity-for-loop/SKILL.md，內容包括：

# Iterative Fix Loop Guidelines (for AI)

該技能為代理提供在自主迴圈中執行開發任務的指導：

- **循環目標：** 完成使用者指定的所有功能，並通過所有測試與靜態檢查。只有當所有測試皆綠且代碼經過格式與lint檢查無誤時，才能輸出完成標記（例如 `<promise>DONE</promise>`）。
- **工作流程：** 遵循測試驅動開發（TDD）原則：
  1. 撰寫或更新測試用例，運行測試觀察失敗。
  2. 編寫或修改程式碼以實現功能，使測試通過。
  3. 進行必要的重構，確保代碼整潔且沒有新的警告。
  4. 重復執行所有測試。若仍有失敗，分析錯誤並回到步驟2修復。
  5. 持續此循環，直到測試全數通過且品質檢查無異議。
- **錯誤處理：** 每次獲得測試失敗訊息時，耐心分析根本原因。優先修復最先阻礙的錯誤。一旦某個錯誤重復出現多次且難以解決，嘗試從不同角度檢視該問題或調整解決方案（例如檢查需求理解是否正確）。
- **禁止事項：** 不要在未經許可的情況下執行刪除大量代碼或重置專案等破壞性操作。避免引入新的外部依賴（除非使用者要求），以免影響環境穩定。遇到不確定的高風險變更（例如資料遷移、性能優化），應在提案後等待使用者確認。
- **完成標準：** 確保程式碼通過所有測試；關鍵功能滿足需求；代碼符合團隊風格和安全指南（無明顯漏洞）。完成時，在最終回答中包含 `<promise>DONE</promise>` 字樣確認。

上述技能作為一份長期知識，將在循環過程中時刻提醒AI遵守既定流程和注意事項。比如強調了TDD步驟，AI 就更可能主動編寫測試或至少執行測試再行修復；列出了完成標準，也降低了AI過早退出的可能性。Skill的內容可以根據項目類型進行調整——例如對前端任務，可加入「通過eslint檢查」「兼容各主流瀏覽器」等條款。

Antigravity 插件系統允許將技能與插件一起發布，安裝插件時技能便自動可用 ￼。我們在 plugin.json 中聲明該技能，使Claude在執行 /for-loop 命令時自動載入它（或插件在Hook中動態注入技能內容到Prompt）。需要注意的是，技能文件過長會佔用上下文，因此我們應盡量簡潔明了地傳達關鍵規範，並善用Markdown標題/列表增強可讀性。實驗證明，有針對性的技能可以讓Claude的表現更加可靠而一致 ￼ ￼。不過正如Claude官方所言，對於多步驟嚴格順序流程，仍需要結合我們前述的Hook來保證執行序列 ￼；技能更多解決的是語義理解和行為偏好問題。

4. 結合現有知識庫： 如果開發者團隊已經有現成的程式碼規範、架構指南等，可以作為Skills或自定義規則導入Antigravity ￼。例如有“後端開發指南”Skill會在代理打開src/api/**檔案時自動加載 ￼。我們的 for-loop 插件可以建議用戶同時啟用相關技能，讓AI在迭代中考慮那些額外約束（如安全標準、性能指南）。技能的自動觸發可透過Antigravity的 hooks.rules設定依據文件路徑模式來實現 ￼ ￼。這種情境感知能進一步減少AI走彎路的機會。例如AI修改到database.js時，自動載入“資料庫最佳實踐”指南，就不易引入SQL隱患。在我們插件的文檔中會建議用戶：根據任務性質，預先配置並啟用相應的技能集合，與 for-loop 插件搭配使用，效果最佳。

安裝、啟動與實例配置

作為一個 Antigravity 插件，antigravity_for_loop 將遵循 Antigravity 插件的標準結構進行開發和發布。我們需要提供插件清單文件 (plugin.json)、命令說明文件，以及 Hook 腳本等。以下是關鍵部分的範例，展示如何安裝和啟用該插件：

1. 插件清單 (plugin.json): 定義插件的基本資訊、可用命令和版本等元數據。例如：

{
  "name": "antigravity_for_loop",
  "version": "0.1.0",
  "description": "自動迭代修復循環插件：每次代碼變更後自動執行測試/建構，持續修改直到測試全綠或達到上限。",
  "author": "YourName",
  "commands": [
    {
      "name": "for-loop",
      "title": "Start Fix Loop",
      "description": "啟動自主修復循環，反覆編譯測試直到完成",
      "snippet": "/for-loop \"${1:任務說明}\" --max-iterations ${2:10} --completion ${3:DONE}"
    },
    {
      "name": "cancel-loop",
      "title": "Cancel Fix Loop",
      "description": "取消當前的修復循環迴圈"
    }
  ],
  "skills": [
    {
      "name": "antigravity-for-loop",
      "autoLoad": true
    }
  ],
  "hooks": {
    "Stop": [
      {
        "type": "shell",
        "command": "hooks/on_stop.sh"
      }
    ]
  }
}

以上 JSON 說明：插件名字為 antigravity_for_loop，目前版本0.1.0，有兩個可用命令（啟動循環和取消循環）。snippet 提供了 Antigravity 編輯器中的快捷填寫模板。我們還宣告瞭一個技能 antigravity-for-loop（它會對應 skills/antigravity-for-loop/SKILL.md 文件），並設定 autoLoad: true 使其在插件作用時自動載入 ￼。最後，我們在 hooks 中註冊了一個 Stop Hook，指定當 Stop 事件發生時執行我們的 Shell 腳本 hooks/on_stop.sh。

2. Hook 腳本 (hooks/on_stop.sh): 這是插件的核心控制腳本，在每次 AI 嘗試結束回合時運行。它決定是否繼續迴圈以及如何構造下一輪輸入。下面給出簡化的實現範例：

#!/usr/bin/env bash
STATE_FILE="$HOME/.antigravity/for-loop-state.json"   # 假設我們將狀態存在這
if [ ! -f "$STATE_FILE" ]; then
  # 沒有活動的循環，允許正常停止
  exit 0
fi

# 讀取狀態 (使用 jq 解析 JSON 示例)
iteration=$(jq -r ".iteration" "$STATE_FILE")
max_iter=$(jq -r ".max_iterations" "$STATE_FILE")
completion_str=$(jq -r ".completion_promise" "$STATE_FILE")

# 檢查停止條件
if [[ $completion_str != "null" ]]; then
  # 如果 AI 最後輸出包含完成標記，且我們確認任務完成
  if grep -q "$completion_str" <<< "$AGENT_LAST_OUTPUT"; then
    # 清理並退出
    rm "$STATE_FILE"
    exit 0
  fi
fi
if (( iteration >= max_iter )); then
  # 達到最大迭代次數，退出循環
  echo "⚠️ 已達迴圈上限 (iteration=$iteration)，停止迴圈。" 1>&2
  rm "$STATE_FILE"
  exit 0
fi

# 如需繼續迭代：
next_iter=$(( iteration + 1 ))

# （可選）執行測試命令獲取最新測試結果。如 AGENT_LAST_OUTPUT 已含結果可省略
test_result=$(npm test --silent || true)

# 簡要提取測試失敗摘要
fail_summary=$(grep -E "FAIL|Error" <<< "$test_result" | head -5 | sed 's/\"/\\\"/g')

# 更新狀態檔
jq ".iteration = $next_iter" "$STATE_FILE" > "$STATE_FILE.tmp" && mv "$STATE_FILE.tmp" "$STATE_FILE"

# 輸出阻斷 JSON，重新注入 prompt + 上輪錯誤提示
jq -n --arg prompt "$(jq -r '.original_prompt' $STATE_FILE)" --arg fail "${fail_summary}" --arg iter "$next_iter" '{
    outcome: { decision: "block" },
    userMessage: ("【迭代\($iter)】測試未通過，自動繼續。上輪錯誤摘要: " + $fail + "\n" + $prompt)
}' 

exit 2   # 阻止 Claude 停止，繼續對話

上面的腳本做了以下事情：檢查狀態檔判斷是否該停，否則執行測試（這裡假定 $AGENT_LAST_OUTPUT 環境變數存有AI最近的輸出內容，或我們手動執行了一次 npm test）。然後更新迭代次數，最後用 jq 輸出一段 JSON。這段 JSON 包含 decision: "block" 來告知平臺阻止退出，以及新的 userMessage：我們組裝了迭代次數標記、上一次的錯誤摘要以及原始Prompt，引導 AI 進入下一輪。腳本以 exit 2 結束以觸發阻斷效果 ￼。

📝 **說明：**上例中使用 AGENT_LAST_OUTPUT、npm test 等來獲取錯誤資訊，實際在 Antigravity 中，我們也可以考慮直接利用 Agent Manager 提供的結果物件或者由 AI 自身輸出的錯誤內容。腳本需要與平臺輸出管線集成，才能正確擷取 AI 的輸出作分析。在開發時，可透過 echo 到 stderr 來打印調試資訊，在Claude Code/Antigravity的日誌窗口觀察（上例中的 echo "⚠️ ..." 即是一個調試輸出，被送到日誌而不影響AI對話）。 ￼

3. 安裝插件： 完成開發後，我們將插件發佈到 Antigravity 的插件市場或者提供給團隊成員。Antigravity 支援類似 VS Code 插件的安裝方式。例如，可以將插件打包成 vsix 或 npm 模組，在 Antigravity IDE 的「Extensions」面板中選擇 “Install from VSIX” 安裝 ￼ ￼。如果我們把 antigravity_for_loop 做成開源插件並發佈到官方Marketplace，使用者也能直接在 Antigravity 中執行類似 /plugin search antigravity_for_loop -> /plugin install antigravity_for_loop@latest 來安裝（Claude Code 插件即是這樣安裝的，只是Antigravity的界面可能不同） ￼ ￼。

安裝後，插件會請求使用者對工作區授權（需要讀寫檔案、執行終端命令等權限）。使用者點擊信任後，即可在命令面板或聊天介面使用我們定義的命令。比如在聊天框輸入：

/for-loop "將本專案所有 Jest 測試遷移到 Vitest" --max-iterations 30 --completion "All tests migrated"

然後按下執行。AI 代理隨即開始在新的分支上進行批量重構，並不斷迭代直到它報告 “All tests migrated” 或做到30次為止 ￼ ￼。用戶也可以在過程中隨時執行 /cancel-loop 來終止。整個體驗和 Claude Code 上的 Ralph 插件相似，但由於我們增加了自動測試和風險控制，用戶會看到 AI 更有條理地一邊改代碼一邊跑測試，且出現異常時會被及時告知介入。

4. 啟動驗證： 初次啟動時，可先在小型專案上試運行看看效果。例如讓 AI 完成一個簡單功能並寫測試，觀察它是否能在循環中自行通過測試。如果過程中 AI 總是卡在某步，可能需要調整 Hook 腳本或技能提示的策略。另外，注意對不同模型的適配：若使用Claude API，要檢查 JSON 格式輸出是否會影響Claude的表現（Claude一般能處理Stop Hook JSON，但我們仍需確保格式精確） ￼。如果使用Gemini模型，則按Antigravity規範處理，可能Stop Hook的機制略有不同，但理念一致。我們應該參考Antigravity的Hook開發文檔，確認 exit 2 和 JSON block 的行為是否完全支持，並調整為平臺推薦的方案（例如某些平臺可能要求 "permissionDecision": "block" 等鍵值）。

總之，antigravity_for_loop 插件在開發者層面需要經過充分的測試。一旦就緒，它將成為 Antigravity IDE 中極具威力的工具：讓 AI 真正做到自主執行整個開發-測試迴圈。開發者可以在下班前把任務交給 AI，第二天查看結果，就像有個 tireless 的夥伴幫你通宵寫代碼、跑綠測一樣 ￼ ￼。當然，我們也強調這並非適用於所有情況：對於需求不明或需要創新判斷的任務，仍然需要人的智慧介入 ￼；但對於那些明確而機械的開發工作，這種插件無疑能大幅提升效率 ￼ ￼。通過以上設計，我們把 Anthropic Ralph Wiggum 的成功模式帶入了 Google Antigravity，為程式開發者提供了一種全新的自動化體驗。  ￼ ￼

參考來源：
	•	Ralph Wiggum 插件原理（Claude Code Stop Hook 機制） ￼ ￼
	•	社群增強版 Ralph Loop 功能（錯誤檢測、斷路器等） ￼ ￼
	•	Antigravity Agent Manager 多步驟執行案例 ￼ ￼
	•	Claude Code / Antigravity 插件開發參考（插件結構與 Hook 用法） ￼ ￼
	•	Prompt 編寫與 AI 自主迴圈實踐經驗 ￼ ￼